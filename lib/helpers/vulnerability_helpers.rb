def escape_markdown_characters(text)
  # text = text.gsub("`","'")

  #["\\","*","_","{","}","[","]","(",")","#","+","-",".","!"]


  ["\\","#"].each do |char|
    text = text.gsub(char,"\\"+char)
  end
  return text
end

class Vulnerability
  attr_accessor :id, :name, :external_link,
    :external_id, :type, :source, :severity,
    :identified, :status, :attack_vectors,
    :url, :confidence_level, :source_code_file,
    :source_code_line, :source_code, :details, :term,
    :score, :file_path, :file_name, :task_name, :task_id,
    :key_suffix, :code_fragment, :match_location, :before,
    :after, :line_number, :status_code, :path,
    :reporter, :reward, :jira_ids, :payload, :app

  def initialize
    @attack_vectors=[]
    @identified = Time.now
    @status = "Open"
    @id = SecureRandom.hex
  end

  def is_valid?
    true
  end



end

class AttackVector

  attr_accessor :type, :name, :method, :payload, :note

  def initialize

  end


end

Result.class_eval do

  before_save :vulnerability_counter
  def vulnerability_counter
    if self.changes.include? "metadata"
      # puts self.changes
      if self.changes.try(:[], "metadata").try(:first).try(:[], "vulnerabilities").nil?
        return
      end
      unless (self.changes.try(:[], "metadata").try(:first).try(:[], "vulnerabilities") - self.changes.try(:[], "metadata").try(:last).try(:[], "vulnerabilities")).blank?
        self.update_vulnerabilities([], false)
      end
    end
  end

  def update_sitemap(sitemap=[], source_name=nil)

    self.metadata["sitemap"] ||= []

    sitemap.each do |url|

      entry = self.metadata["sitemap"].select{|entry| entry["url"] == url}.first
      if(!entry)
        entry = {}
        entry["url"] = url
        entry["identified"] = entry["last_seen"] = Time.now
        begin
          uri = URI.parse(url)
          entry["scheme"] = uri.scheme
          entry["host"] = uri.host

          path = uri.path.split("/")
          if(path.last.to_s.include?("."))
            entry["endpoint"] = path.pop
          end

          entry["path"] = path.blank? ? "/" : path.join("/")
          entry["source"] = source_name if source_name

        rescue
        end
        self.metadata["sitemap"] << entry
      else
        entry["last_seen"] = Time.now
        entry["source"] ||= source_name if source_name
      end
    end



  end

  def update_vulnerabilities(vulnerabilities=[], save_result=true)
    puts "Merging..."
    self.metadata ||={}
    self.metadata["vulnerabilities"] ||=[]

    self.metadata["vulnerabilities"].each do |vuln|

      unless vuln.try(:[], "jira_ids").to_s == ""
        vuln["jira_ids"] = vuln["jira_ids"].gsub(/\s+/, "").upcase
      end


    end

    vulnerabilities.each do |v|
      if v.severity == "observation"
        r = find_duplicate_vulnerability(v, true)
      else
        r = find_duplicate_vulnerability(v)
      end

      # v.source = Array(v.source)
      # self.metadata["vulnerabilities"] << JSON.parse(v.to_json)
      # else
      #r = find_duplicate_vulnerability(v)
      if(r.present?)

        r = r.first

        r["source"] ||= []
        if(!r["source"].include?(v.source))
          r["source"] << v.source
          r["source"].uniq!
        end

        r["external_link"] ||={}
        r["external_link"].merge(v.external_link || {})

        v.attack_vectors.each do |vector|
          r["attack_vectors"] ||=[]
          existing_vector = find_duplicate_attack_vector(r["attack_vectors"], v, vector)
          if(existing_vector.blank?)
            r["attack_vectors"] << JSON.parse(vector.to_json)
          end

        end

        if(r["status"] == "Remediated")
          r["status"] = "Reopened"
        elsif(r["status"] == "Auto-Remediated")
          r["status"] = "Reopened"
        elsif(r["status"] == "False Positive" && Time.now - Time.parse(r["identified"]) > 30.days)
          r["status"] = "Reopened"
          r["identified"] = Time.now
        end

        r["reporter"] = v.reporter if v.reporter
        r["reward"] = v.reward if v.reward

        # Do not want to overwrite existing details
        # r["details"] = v.details

      else
        v.identified = Time.now
        v.severity = v.severity.to_s.titleize
        if(v.source.class == String || v.source.class == Array)
          v.source = Array(v.source).uniq
        else
          v.source = [v.source].uniq
        end


        self.metadata["vulnerabilities"] << JSON.parse(v.to_json)

      end
      # end
    end

    self.metadata["vulnerability_count"] ||={}
    open_vulnerabilities = self.metadata["vulnerabilities"].select{|v| v["status"].match(/open/i) }

    self.metadata["vulnerability_count"]["closed"] = self.metadata["vulnerabilities"].select{|v| !v["status"].match(/open/i) }.count

    ["critical", "high", "medium", "low", "informational", "observation"].each do |severity|
      self.metadata["vulnerability_count"][severity] = open_vulnerabilities.select{|v| v["severity"].to_s.downcase == severity}.count
    end

    #before_save
    # if metadata has changed (only runs if metadata["vulnerabilities"])
    # self.changes.include? "metadata"
    #

    # Count distinct key suffix
    counted = Hash.new(0)
    open_vulnerabilities.each { |h| unless h["key_suffix"].nil? then counted[h["key_suffix"]] += 1 end}
    counted = Hash[counted.map {|k,v| [k,v] }]

    self.metadata["vulnerability_count"]["key_suffix"] = counted

    # Count distinct task ids
    counted = Hash.new(0)
    open_vulnerabilities.each { |h| unless h["task_id"].nil? then counted[h["task_id"]] += 1 end}
    counted = Hash[counted.map {|k,v| [k,v] }]

    self.metadata["vulnerability_count"]["task_id"] = counted


    # Count distinct sources
    counted = Hash.new(0)

    open_vulnerabilities.each { |vuln|
      vuln.each { |key,val|
        if key == "source"
          vuln[key].each { | task_type|
            counted[task_type] += 1
          }
        end
      }
    }
    counted = Hash[counted.map {|k,v| [k,v] }]

    self.metadata["vulnerability_count"]["source"] = counted
    self.metadata["vulnerability_count"]["open"] = open_vulnerabilities.select{|v| v["severity"].to_s.downcase != "informational"}.count

    if self.changed? && save_result
      self.save
    end


    # Update flag (has_vulnerabilities, counts of vulnerabilities by severity)

    # Update identified to Open, identified now on new vulns

  end

  def auto_remediate(task_id, url, term=nil, payload=nil)
    if self.metadata["vulnerabilities"].present?
      if term.to_s == "" and payload.to_s == ""
        self.metadata["vulnerabilities"].each_with_object({}) do |vuln|
          if vuln["url"] == url && vuln["task_id"] == task_id

            vuln["status"] = "Auto Remediated"
          end
        end
      elsif payload.to_s == ""
        self.metadata["vulnerabilities"].each_with_object({}) do |vuln|
          if vuln["url"] == url && vuln["task_id"] == task_id && vuln["term"] == term
            vuln["status"] = "Auto Remediated"
          end
        end
      elsif term.to_s == ""
        self.metadata["vulnerabilities"].each_with_object({}) do |vuln|
          if vuln["url"] == url && vuln["task_id"] == task_id && vuln["payload"] == payload
            vuln["status"] = "Auto Remediated"
          end
        end
      else
        self.metadata["vulnerabilities"].each_with_object({}) do |vuln|
          if vuln["url"] == url && vuln["task_id"] == task_id && vuln["term"] == term && vuln["payload"] == payload
            vuln["status"] = "Auto Remediated"
          end
        end
      end
    end

    if self.changed?
      self.save!
    end
  end


  def find_duplicate_vulnerability(vulnerability, is_observation=false)
    # locations: content, path, headers
    # code_fragment

    # This is a static analyzer match for content
    if vulnerability.match_location == "content"
      self.metadata["vulnerabilities"].select{|v| v["url"] == vulnerability.url && v["code_fragment"] == vulnerability.code_fragment && v["term"] == vulnerability.term}
      # This is a static analyzer match for paths
    elsif vulnerability.match_location == "path"
      self.metadata["vulnerabilities"].select{|v| v["url"] == vulnerability.url && v["term"] == vulnerability.term}
      # This matches curl analyzers running on headers
    elsif vulnerability.match_location == "headers"
      self.metadata["vulnerabilities"].select{|v| v["url"] == vulnerability.url && v["term"] == vulnerability.term}
    else
      self.metadata["vulnerabilities"].select{|v| v["url"] == vulnerability.url && v["type"] == vulnerability.type}
    end
  end

  def find_duplicate_attack_vector(vector_metadata, vulnerability, vulnerability_vector)
    vector_metadata.select{|v| v["type"] == vulnerability_vector.type && v["name"] == vulnerability_vector.name }
  end

end
